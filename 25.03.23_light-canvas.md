先实现 Canvas 版本，用 Canvas 2D API 实现基础功能（如精灵渲染、变换、场景树），再逐步优化。阅读 PixiJS 的 [源码](https://github.com/pixijs/pixijs) 重点关注 `core` 和 `math` 模块。HTML5 Canvas → WebGL 基础（着色器、缓冲区）→ 2D 数学（矩阵、向量）。WebGL 优化（批处理、纹理管理）→ 2D 物理引擎整合 → 复杂特效（如光照、粒子）。

### 一、基础理论

1. **图形渲染原理**

   - **渲染管线**：理解顶点处理 → 光栅化 → 片段处理的流程。
   - **坐标系统**：世界坐标、局部坐标、屏幕坐标的转换关系。
   - **双缓冲机制**：避免画面撕裂，实现平滑渲染（通过 Canvas 或 WebGL 的默认机制实现）。

2. **WebGL/Canvas 基础**

   - **Canvas 2D API**：`drawImage`、路径绘制、变换矩阵等基本操作。
   - **WebGL 核心概念**：
     - 着色器（Vertex Shader / Fragment Shader）
     - 缓冲区（VBO、IBO）
     - 纹理与帧缓冲区（FBO）

3. **资源管理**
   - 纹理加载与缓存（如 `Image` 对象管理）
   - 对象池模式（优化频繁创建/销毁的对象，如粒子）。

---

### 二、图形数学

1. **向量与矩阵**

   - **2D 向量运算**：加减、点积、长度、归一化（用于方向计算、碰撞检测）。
   - **3x3 变换矩阵**（2D 图形核心）：2D 变换矩阵（平移、旋转、缩放）
   - **矩阵乘法**：组合多个变换（如先缩放再旋转最后平移）。

2. **坐标变换**

   - **模型-视图-投影（MVP）矩阵**（可合并为单个矩阵）：
     - **模型矩阵**：物体自身的变换（位置/旋转/缩放）。
     - **视图矩阵**：摄像机视角（2D 中通常为单位矩阵或简单平移）。
     - **投影矩阵**：将坐标映射到屏幕（如正交投影 `ortho`）。

3. **几何计算**
   - **包围盒（AABB）**：快速判断对象可见性/碰撞。
   - **几何相交检测**：点与矩形、圆形的碰撞（用于交互事件）。
   - **UV 映射**：将纹理坐标映射到几何体（如精灵的纹理贴图）。

---

### 三、核心模块设计

1. **场景图（Scene Graph）**

   - 树形结构管理渲染对象（父-子层级关系）。
   - 局部坐标 → 世界坐标的递归计算（通过矩阵级联实现）。

2. **渲染器（Renderer）**

   - **Canvas 渲染器**：
     - 实现批量绘制（如自动批处理相同纹理的精灵）。
     - 状态管理（保存/恢复 Canvas 上下文状态）。
   - **WebGL 渲染器**：
     - 着色器程序管理。
     - 顶点数据提交（通过 `gl.drawArrays` 或 `gl.drawElements`）。

3. **显示对象（DisplayObject）**

   - 基类设计：位置、旋转、缩放、锚点、透明度等属性。
   - 子类实现：`Sprite`（纹理）、`Graphics`（矢量绘图）、`Text`（文本）。

4. **交互系统**
   - 事件分发机制（如点击、拖拽事件的冒泡与捕获）。
   - 基于包围盒或像素的命中测试（`hitTest`）。

---

### 四、优化方向

1. **性能优化**
   - 脏矩形渲染（仅重绘变化区域）
   - 批处理（合并 Draw Call）
2. **特效支持**
   - 混合模式（Blend Mode）
   - 滤镜（如模糊、颜色矩阵）
